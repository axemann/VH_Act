/*
1. Download and install VirtualHere server and client parts.
2. Install openssl development package: sudo apt-get install libssl-dev
3. Compile activator: gcc activator.c -lcrypto -o activator
4. Find your serial number form client.
5. Stop server and run activator: sudo ./activator serverFileName serialNumber
6. Copy generated license string from console to config.ini file.
7. Start server.
*/

#include <string.h>
#include <stdlib.h>
#include <stdio.h>
#include </usr/include/openssl/sha.h>
#include </usr/include/openssl/evp.h>
#include </usr/include/openssl/ecdsa.h>
#define MAX(a,b) (((a)>(b))?(a):(b))

const unsigned char g_pkey_ego[29] = {
	0x04,0xCB,0x16,0x12,0x55,0x1C,0xBC,0xED,0x31,0x98,0x03,0x4A,0x8F,0x2E,0xB2,0x17,
	0xD3,0xC7,0xC4,0xA4,0x42,0x69,0xCD,0x19,0xED,0x42,0xCA,0xEE,0x3D
};

const unsigned char g_pkey_moi[29] = {
	0x04,0x60,0xf5,0xf7,0xc2,0xf7,0xee,0x90,0x3e,0xe7,0x51,0x3c,0x7a,0x2f,0x65,0x2e,
	0xab,0xdb,0xde,0xc5,0xa4,0x58,0xe7,0xd4,0xdd,0x26,0xce,0x2b,0xd9
};

const unsigned char g_prikey[201] = {
	0x30,0x81,0xc6,0x02,0x01,0x01,0x04,0x0e,0x56,0x1e,0x78,0x9f,0x3f,0x37,0xc0,0x61,
	0xdd,0x4f,0xd6,0xec,0x63,0x79,0xa0,0x81,0x8e,0x30,0x81,0x8b,0x02,0x01,0x01,0x30,
	0x1a,0x06,0x07,0x2a,0x86,0x48,0xce,0x3d,0x01,0x01,0x02,0x0f,0x00,0xdb,0x7c,0x2a,
	0xbf,0x62,0xe3,0x5e,0x66,0x80,0x76,0xbe,0xad,0x20,0x8b,0x30,0x37,0x04,0x0e,0xdb,
	0x7c,0x2a,0xbf,0x62,0xe3,0x5e,0x66,0x80,0x76,0xbe,0xad,0x20,0x88,0x04,0x0e,0x65,
	0x9e,0xf8,0xba,0x04,0x39,0x16,0xee,0xde,0x89,0x11,0x70,0x2b,0x22,0x03,0x15,0x00,
	0x00,0xf5,0x0b,0x02,0x8e,0x4d,0x69,0x6e,0x67,0x68,0x75,0x61,0x51,0x75,0x29,0x04,
	0x72,0x78,0x3f,0xb1,0x04,0x1d,0x04,0x09,0x48,0x72,0x39,0x99,0x5a,0x5e,0xe7,0x6b,
	0x55,0xf9,0xc2,0xf0,0x98,0xa8,0x9c,0xe5,0xaf,0x87,0x24,0xc0,0xa2,0x3e,0x0e,0x0f,
	0xf7,0x75,0x00,0x02,0x0f,0x00,0xdb,0x7c,0x2a,0xbf,0x62,0xe3,0x5e,0x76,0x28,0xdf,
	0xac,0x65,0x61,0xc5,0x02,0x01,0x01,0xa1,0x20,0x03,0x1e,0x00,0x04,0x60,0xf5,0xf7,
	0xc2,0xf7,0xee,0x90,0x3e,0xe7,0x51,0x3c,0x7a,0x2f,0x65,0x2e,0xab,0xdb,0xde,0xc5,
	0xa4,0x58,0xe7,0xd4,0xdd,0x26,0xce,0x2b,0xd9
};

static const char g_lkp[] =
	"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/";

////////////////////////////////////////////////////////////////////////////////////
static int do_fignja(char* encoded, const char* inp, int len)
{
	int i;
	char* p = encoded;

	for (i = 0; i < len - 2; i += 3)
	{
		*p++ = g_lkp[(inp[i] >> 2) & 0x3F];
		*p++ = g_lkp[((inp[i] & 0x3) << 4) | ((int) (inp[i + 1] & 0xF0) >> 4)];
		*p++ = g_lkp[((inp[i + 1] & 0xF) << 2) | ((int) (inp[i + 2] & 0xC0) >> 6)];
		*p++ = g_lkp[inp[i + 2] & 0x3F];
	}

	if (i < len)
	{
		*p++ = g_lkp[(inp[i] >> 2) & 0x3F];
		if (i == (len - 1))
		{
			*p++ = g_lkp[((inp[i] & 0x3) << 4)];
			*p++ = '=';
		}
		else
		{
			*p++ = g_lkp[((inp[i] & 0x3) << 4) | ((int) (inp[i + 1] & 0xF0) >> 4)];
			*p++ = g_lkp[((inp[i + 1] & 0xF) << 2)];
		}
		*p++ = '=';
	}

	*p++ = 0;
	return p - encoded;
}

////////////////////////////////////////////////////////////////////////////////////
static int do_dva(const char* sn, int connections)
{
	int signLen;
	unsigned char *ptr, digest[20], buf[0x100], fub[0x100];
	const unsigned char* pp;
	EVP_MD_CTX *ctx;
	ECDSA_SIG *sig;
	EC_KEY *eckey;

	ctx = EVP_MD_CTX_create();
	if(!ctx)
		return 0;
	EVP_DigestInit_ex(ctx, EVP_sha1(), NULL);
	EVP_DigestUpdate(ctx, buf, snprintf(buf, sizeof(buf), "%s,%d", sn, connections));
	EVP_DigestFinal_ex(ctx, digest, &signLen);
	EVP_MD_CTX_destroy(ctx);
	
	eckey = EC_KEY_new_by_curve_name(NID_secp112r1);
	if(!eckey)
		return 0;
	pp = g_prikey;
	eckey = d2i_ECPrivateKey(&eckey, &pp, sizeof(g_prikey));
	sig = ECDSA_do_sign(digest, sizeof(digest), eckey);
	EC_KEY_free(eckey);
	ptr = buf;
	do_fignja(fub, buf, i2d_ECDSA_SIG(sig, &ptr));
	ECDSA_SIG_free(sig);
	printf("License=%s,%d,%s\n", sn, connections, fub);
	return 1;
}

////////////////////////////////////////////////////////////////////////////////////
static int do_raz(const char* fname)
{
	FILE* f;
	int i, j, k, len;
	char* ptr;

	f = fopen(fname, "r+");
	if(!f)
		return 0;
	fseek(f, 0, SEEK_END);
	len = ftell(f);
	ptr = malloc(len);
	if(ptr)
	{
		fseek(f, 0, SEEK_SET);
		fread(ptr, 1, len, f);
		for(k = j = i = 0; i < len - sizeof(g_pkey_ego); ++i)
		{
			if(!memcmp(&ptr[i], g_pkey_ego, sizeof(g_pkey_ego)))
			{
				fseek(f, i, SEEK_SET);
				fwrite(g_pkey_moi, 1, sizeof(g_pkey_moi), f);
				++j;
			}
			else if(!memcmp(&ptr[i], g_pkey_moi, sizeof(g_pkey_moi)))
			{
				++k;
			}
		}
		printf("patched (%d:%d)\n", j, k);
	}
	fclose(f);
	return MAX(j, k);
}

////////////////////////////////////////////////////////////////////////////////////
int main(int argc, char** argv)
{
	if(argc != 3)
	{
		printf("usage: sudo ./activator vhusbdi386 123456789abcdef\n"
				", where vhusbdi386 is a server executable name and\n"
				"123456789abcdef - serial number.\n");
		return -1;
	}

	if(!do_raz(argv[1]))
	{
		printf("error while patching %s\n", argv[1]);
	}

	do_dva(argv[2], 20);
	return 0;
}



